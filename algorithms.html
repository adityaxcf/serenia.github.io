<!DOCTYPE html>
<html>
<head>
    <title>Algorithms in Serenia City</title>
    <link rel="stylesheet" href="styles.css">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
</head>
<body>

<header>
    <h1>Algorithms Used in Serenia</h1>
    <p>Real-world, business-oriented applications inside a smart city model</p>
</header>

<nav>
    <a href="index.html">Home</a>
    <a href="project.html">Project</a>
    <a href="citylayout.html">City Layout</a>
    <a href="algorithms.html">Algorithms</a>
    <a href="about.html">About DAA</a>
</nav>


<!-- --------------------------
     1. DIJKSTRA'S ALGORITHM
----------------------------- -->
<section class="card fade-in">
    <h2>1. Dijkstra’s Algorithm – Smart Transportation & Emergency Response</h2>

    <p>
        In Serenia, the transportation network functions like a real smart-city business model.
        Dijkstra’s algorithm powers the <strong>Smart Routing Engine</strong> that enables:
    </p>

    <ul>
        <li>Fastest emergency routes for ambulances and fire vehicles</li>
        <li>Dynamic re-routing during traffic congestion</li>
        <li>Optimised public transport schedules</li>
    </ul>

    <p>
        Adopting shortest-path logic reduces fuel/time costs, improves emergency response times,
        and enables premium routing services (priority routing, SLA planning etc.).
    </p>

    <details class="algo-drop">
        <summary>Show Algorithm</summary>
        <pre>
function dijkstra(graph, source):
    dist = array of infinity
    dist[source] = 0
    visited = empty set
    pq = priority queue
    pq.push(source, 0)

    while pq is not empty:
        u = pq.pop()
        if u in visited:
            continue
        visited.add(u)

        for each neighbor v of u:
            w = weight(u, v)
            if dist[u] + w < dist[v]:
                dist[v] = dist[u] + w
                pq.push(v, dist[v])

    return dist
        </pre>
    </details>
</section>


<!-- --------------------------
     2. BFS
----------------------------- -->
<section class="card fade-in delay-1">
    <h2>2. BFS – Utility Distribution & City-Wide Service Coverage</h2>

    <p>
        BFS models Serenia’s <strong>essential service propagation</strong> system. It simulates how
        water, electricity, waste collection, and public Wi-Fi expand level-by-level.
        Municipal departments use BFS-style mapping to ensure:
    </p>

    <ul>
        <li>Every home receives electricity & water</li>
        <li>Garbage routes cover all neighbourhoods</li>
        <li>Emergency services can reach every zone</li>
    </ul>

    <details class="algo-drop">
        <summary>Show Algorithm</summary>
        <pre>
function BFS(graph, start):
    visited = empty set
    queue = empty queue
    queue.enqueue(start)
    visited.add(start)

    while queue is not empty:
        node = queue.dequeue()
        for each neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.enqueue(neighbor)
        </pre>
    </details>
</section>


<!-- --------------------------
     3. DFS
----------------------------- -->
<section class="card fade-in delay-2">
    <h2>3. DFS – Security, Surveillance & Monitoring</h2>

    <p>
        DFS models Serenia’s smart-security inspection system. It is used for:
    </p>

    <ul>
        <li>Deep scanning of CCTV camera paths</li>
        <li>Building-wise security sweeps</li>
        <li>Fire-escape and maintenance route checks</li>
    </ul>

    <details class="algo-drop">
        <summary>Show Algorithm</summary>
        <pre>
function DFS(node):
    visited.add(node)
    for each neighbor in graph[node]:
        if neighbor not in visited:
            DFS(neighbor)
        </pre>
    </details>
</section>


<!-- --------------------------
     4. MST (KRUSKAL)
----------------------------- -->
<section class="card fade-in delay-3">
    <h2>4. Minimum Spanning Tree – Cost-Optimised Infrastructure Planning</h2>

    <p>
        MST thinking helps Serenia save budget while building:
    </p>

    <ul>
        <li>Streetlight wiring networks</li>
        <li>Electrical grid connections</li>
        <li>Underground fibre-optic and utility pipelines</li>
    </ul>

    <details class="algo-drop">
        <summary>Show Algorithm</summary>
        <pre>
function kruskal(graph):
    mst = empty set
    sort edges by weight
    create disjoint set DSU

    for each edge (u, v, w):
        if find(u) != find(v):
            union(u, v)
            mst.add((u, v, w))

    return mst
        </pre>
    </details>
</section>


<!-- --------------------------
     5. GREEDY
----------------------------- -->
<section class="card fade-in delay-4">
    <h2>5. Greedy Strategy – Quick City-Level Decision Making</h2>

    <p>
        Serenia uses greedy logic for fast local decisions without heavy computation:
    </p>

    <ul>
        <li>Choosing next garbage pickup point</li>
        <li>Assigning police patrolling routes</li>
        <li>Load balancing during peak hours</li>
    </ul>

    <details class="algo-drop">
        <summary>Show Algorithm</summary>
        <pre>
function greedy(problem):
    solution = empty set

    while not finished(problem):
        choice = best_local_choice(problem)
        solution.add(choice)
        update(problem, choice)

    return solution
        </pre>
    </details>
</section>


<!-- --------------------------
     6. DIVIDE & CONQUER
----------------------------- -->
<section class="card fade-in delay-5">
    <h2>6. Divide & Conquer – Zonal Planning & Management</h2>

    <p>
        Serenia is divided into smaller sub-regions (residential, commercial, tech-park,
        government zone etc.). Each zone is treated as a subproblem.
    </p>

    <details class="algo-drop">
        <summary>Show Algorithm</summary>
        <pre>
function divideAndConquer(problem):
    if small(problem):
        return direct_solution(problem)

    left, right = split(problem)
    L = divideAndConquer(left)
    R = divideAndConquer(right)

    return combine(L, R)
        </pre>
    </details>
</section>


<!-- --------------------------
     7. DP
----------------------------- -->
<section class="card fade-in delay-6">
    <h2>7. Dynamic Programming – Resource Allocation</h2>

    <p>
        DP supports Serenia’s healthcare & emergency resource planning:
    </p>

    <ul>
        <li>Optimal hospital bed allocation</li>
        <li>Staff scheduling</li>
        <li>Inventory distribution</li>
    </ul>

    <details class="algo-drop">
        <summary>Show Algorithm</summary>
        <pre>
function DP():
    dp = array
    initialise dp

    for i from start to end:
        dp[i] = best value from previous states

    return dp[end]
        </pre>
    </details>
</section>


<footer>© 2025 Aditya</footer>

</body>
</html>
