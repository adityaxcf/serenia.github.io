<!DOCTYPE html>
<html>
<head>
    <title>Algorithms in Serenia City</title>
    <link rel="stylesheet" href="styles.css">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<header>
    <h1>Algorithms Used in Serenia</h1>
    <p>Medium-detailed explanations of how each algorithm fits into a smart city</p>
</header>

<nav>
    <a href="index.html">Home</a>
    <a href="project.html">Project</a>
    <a href="citylayout.html">City Layout</a>
    <a href="algorithms.html">Algorithms</a>
    <a href="about.html">About DAA</a>
</nav>


<!-- 1. DIJKSTRA -->
<section class="card">
    <h2>1. Dijkstra’s Algorithm: Transportation and Emergency Movement</h2>

    <p>
        Serenia uses the idea of Dijkstra’s algorithm to plan how vehicles move across the city.
        It helps estimate which route is the fastest based on distance, junctions and road conditions.
        This becomes especially useful for emergency vehicles like ambulances or fire engines, where
        choosing the quickest possible route can make a major difference. Even everyday transport inside
        the city benefits because the algorithm reduces unnecessary travel time and helps avoid slower paths.
        It basically acts like a simple navigation system that always tries to find the most efficient path
        between two points in the city.
    </p>

    <details class="algo-drop">
        <summary>Show Algorithm</summary>
        <div class="algo-box">
<pre>
function dijkstra(graph, source):
    dist = infinity array
    dist[source] = 0
    pq = priority queue
    pq.push(source, 0)

    while pq not empty:
        u = pq.pop()
        for each v in neighbors(u):
            w = weight(u, v)
            if dist[u] + w < dist[v]:
                dist[v] = dist[u] + w
                pq.push(v, dist[v])

    return dist
</pre>
        </div>
    </details>
</section>


<!-- 2. BFS -->
<section class="card">
    <h2>2. BFS: Utility Spread and Service Reachability</h2>

    <p>
        BFS helps check how well essential services reach every part of Serenia. Since BFS moves level by
        level, it matches real situations where utilities expand outward from a central point. This is used
        to understand how water supply, electricity, garbage collection and even internet coverage might reach
        different neighbourhoods. If a certain zone cannot be reached in the BFS simulation, it usually means
        that the city needs to fix missing links or improve service access there. It gives a simple but clear
        picture of how connected the city really is.
    </p>

    <details class="algo-drop">
        <summary>Show Algorithm</summary>
        <div class="algo-box">
<pre>
function BFS(graph, start):
    visited = set()
    queue = [start]
    visited.add(start)

    while queue not empty:
        node = queue.pop(0)
        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
</pre>
        </div>
    </details>
</section>


<!-- 3. DFS -->
<section class="card">
    <h2>3. DFS: Security Checks and Internal Exploration</h2>

    <p>
        DFS is used in Serenia to represent tasks that require deep exploration before moving on.
        This fits scenarios like building inspections, checking every corridor inside a complex,
        or scanning CCTV routes in a fixed order. DFS explores one full path at a time which makes
        it useful for internal checks where nothing should be skipped. It also helps simulate how
        emergency teams might search buildings or restricted areas by following one route completely
        before switching to another.
    </p>

    <details class="algo-drop">
        <summary>Show Algorithm</summary>
        <div class="algo-box">
<pre>
function DFS(node):
    visited.add(node)
    for neighbor in graph[node]:
        if neighbor not in visited:
            DFS(neighbor)
</pre>
        </div>
    </details>
</section>


<!-- 4. MST -->
<section class="card">
    <h2>4. Minimum Spanning Tree: Cost-Friendly City Connections</h2>

    <p>
        MST ideas help Serenia reduce construction cost when connecting multiple locations.
        Whenever the city needs to lay out streetlights, power lines, underground cables
        or communication wires, MST helps design the layout so that every area is connected
        while using the minimum amount of material. This naturally lowers installation cost
        and future maintenance effort. It also gives planners a simple way to decide which
        connections are necessary and which ones are extra or inefficient.
    </p>

    <details class="algo-drop">
        <summary>Show Algorithm</summary>
        <div class="algo-box">
<pre>
function kruskal(graph):
    sort edges by weight
    DSU = disjoint set
    mst = []

    for (u, v, w) in edges:
        if find(u) != find(v):
            union(u, v)
            mst.append((u, v, w))

    return mst
</pre>
        </div>
    </details>
</section>


<!-- 5. GREEDY -->
<section class="card">
    <h2>5. Greedy Method: Quick Local Decisions</h2>

    <p>
        Serenia uses the greedy approach in areas where fast and practical decisions are more
        useful than perfect long-term solutions. This includes choosing which garbage pickup
        point to visit next, assigning traffic police to the nearest busy road or selecting a
        maintenance task that should be handled first. The greedy method works well here because
        it focuses on the best available option at that moment, allowing the city to respond
        quickly without trying to compute every possible outcome.
    </p>

    <details class="algo-drop">
        <summary>Show Algorithm</summary>
        <div class="algo-box">
<pre>
function greedy(problem):
    solution = []
    while not finished(problem):
        best = best_local_choice(problem)
        solution.append(best)
        update(problem, best)
    return solution
</pre>
        </div>
    </details>
</section>


<!-- 6. DIVIDE & CONQUER -->
<section class="card">
    <h2>6. Divide and Conquer: Zonal Planning and City Structure</h2>

    <p>
        When designing Serenia, the city was split into smaller zones like residential blocks,
        commercial areas, government zones and green spaces. Each smaller part is easier to
        design, analyse and manage. This mirrors the divide-and-conquer idea where a big
        problem is broken into simpler sections that are solved one at a time and then combined.
        This approach makes expansion easier because new zones can be added without disturbing
        the rest of the city layout.
    </p>

    <details class="algo-drop">
        <summary>Show Algorithm</summary>
        <div class="algo-box">
<pre>
function divideAndConquer(problem):
    if small(problem):
        return solve(problem)

    left, right = split(problem)
    a = divideAndConquer(left)
    b = divideAndConquer(right)
    return combine(a, b)
</pre>
        </div>
    </details>
</section>


<!-- 7. DP -->
<section class="card">
    <h2>7. Dynamic Programming: Resource Planning and Allocation</h2>

    <p>
        Serenia often deals with limited resources such as hospital beds, emergency vehicles,
        repair teams or funding for maintenance. DP helps in these situations by breaking the
        allocation problem into stages and choosing the best option at each step without wasting
        resources. This ensures that future decisions remain flexible while still maintaining
        efficiency. DP concepts fit well into scheduling tasks, distributing staff and balancing
        workload across different parts of the city.
    </p>

    <details class="algo-drop">
        <summary>Show Algorithm</summary>
        <div class="algo-box">
<pre>
function DP():
    dp = array
    initialize dp

    for i in range:
        dp[i] = best value using previous states

    return dp[end]
</pre>
        </div>
    </details>
</section>


<footer>© 2025 Aditya</footer>

</body>
</html>
