<!DOCTYPE html>
<html>
<head>
    <title>Algorithms in Serenia City</title>
    <link rel="stylesheet" href="styles.css">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>

<body>

<header>
    <h1>Algorithms Used in Serenia</h1>
    <p>Real-world, business-oriented applications inside a smart city model</p>
</header>

<nav>
    <a href="index.html">Home</a>
    <a href="project.html">Project</a>
    <a href="citylayout.html">City Layout</a>
    <a href="algorithms.html">Algorithms</a>
    <a href="about.html">About DAA</a>
</nav>

<!-- 1. DIJKSTRA -->
<section class="card fade-in">
    <h2>1. Dijkstra’s Algorithm – Smart Transportation & Emergency Response</h2>
    <p>
        In Serenia, the transportation network functions like a real smart-city business model.
        Dijkstra’s algorithm is used as the core of the “Smart Routing Engine” that powers:
        <ul>
            <li>Fastest emergency routes for ambulances and fire vehicles</li>
            <li>Dynamic re-routing during traffic congestion</li>
            <li>Optimized public transport schedules</li>
        </ul>
        Adopting shortest-path logic reduces fuel and time costs, improves emergency response times,
        and enables premium routing services (paid priority routing, SLA for emergency response).
    </p>

    <details class="algo-drop">
        <summary>Show Algorithm</summary>
        <pre>
function dijkstra(graph, source):
    dist = array of infinity
    dist[source] = 0
    visited = empty set
    pq = priority queue
    pq.push(source, 0)

    while pq not empty:
        u = pq.pop()
        if u in visited: continue
        visited.add(u)

        for each v in neighbors(u):
            w = weight(u, v)
            if dist[u] + w &lt; dist[v]:
                dist[v] = dist[u] + w
                pq.push(v, dist[v])

    return dist
        </pre>
    </details>
</section>

<!-- 2. BFS -->
<section class="card fade-in delay-1">
    <h2>2. BFS – Utility Distribution & City-Wide Service Coverage</h2>
    <p>
        BFS is used to design Serenia’s essential service distribution model.
        It simulates how water, electricity, waste collection and public Wi-Fi propagate
        across the city level-by-level ensuring even coverage.
        Municipal utilities and ISPs use similar coverage planning to avoid gaps and optimize rollout costs.
    </p>

    <details class="algo-drop">
        <summary>Show Algorithm</summary>
        <pre>
function BFS(graph, start):
    visited = set()
    queue = empty queue
    queue.enqueue(start)
    visited.add(start)

    while queue not empty:
        node = queue.dequeue()
        for v in neighbors(node):
            if v not in visited:
                visited.add(v)
                queue.enqueue(v)
        </pre>
    </details>
</section>

<!-- 3. DFS -->
<section class="card fade-in delay-2">
    <h2>3. DFS – Security Scanning & Inspection Systems</h2>
    <p>
        DFS is applied for deep, sequential inspections: building interiors, CCTV route scans,
        or infrastructure audits. Security and inspection firms use DFS-like traversals when a
        thorough, path-by-path scan is required.
    </p>

    <details class="algo-drop">
        <summary>Show Algorithm</summary>
        <pre>
function DFS(node):
    visited.add(node)
    for v in neighbors(node):
        if v not in visited:
            DFS(v)
        </pre>
    </details>
</section>

<!-- 4. MST -->
<section class="card fade-in delay-3">
    <h2>4. Minimum Spanning Tree – Cost-Optimized Infrastructure</h2>
    <p>
        MST minimizes total connection length and cost for networks such as streetlights,
        fiber cables, pipelines and microgrids. Telecom and utilities use MST logic to reduce
        installation and maintenance costs while maintaining connectivity.
    </p>

    <details class="algo-drop">
        <summary>Show Algorithm</summary>
        <pre>
function kruskal(graph):
    mst = empty set
    sort edges by weight
    create DSU

    for each (u, v, w) in edges:
        if find(u) != find(v):
            union(u, v)
            mst.add((u, v, w))

    return mst
        </pre>
    </details>
</section>

<!-- 5. GREEDY -->
<section class="card fade-in delay-4">
    <h2>5. Greedy Strategy – Daily Operational Optimization</h2>
    <p>
        Greedy methods support quick decisions in logistics and operations: next garbage pickup,
        short-term resource allocation, or simple scheduling. They’re useful when fast, local-optimal
        choices give good practical results with minimal compute overhead.
    </p>

    <details class="algo-drop">
        <summary>Show Algorithm</summary>
        <pre>
function greedy(problem):
    solution = empty set
    while not done:
        choice = best_local_choice()
        solution.add(choice)
        update(problem, choice)
    return solution
        </pre>
    </details>
</section>

<!-- 6. DIVIDE & CONQUER -->
<section class="card fade-in delay-5">
    <h2>6. Divide & Conquer – Smart Zoning for Scalable Growth</h2>
    <p>
        Divide & Conquer is the planning backbone: split the city into manageable zones,
        solve each zone’s plan independently, then combine. This approach helps planners and
        investors scale Serenia in stages and measure ROI per zone.
    </p>

    <details class="algo-drop">
        <summary>Show Algorithm</summary>
        <pre>
function divideAndConquer(problem):
    if small(problem):
        return direct_solution
    left, right = split(problem)
    L = divideAndConquer(left)
    R = divideAndConquer(right)
    return combine(L, R)
        </pre>
    </details>
</section>

<!-- 7. DP -->
<section class="card fade-in delay-6">
    <h2>7. Dynamic Programming – Hospital & Resource Allocation Model</h2>
    <p>
        DP is used for scheduling, allocation and forecasting: assigning beds and staff,
        predicting demand spikes, and optimizing budgets. Large hospitals and emergency systems
        use DP-like planning to improve utilization and reduce downtime.
    </p>

    <details class="algo-drop">
        <summary>Show Algorithm</summary>
        <pre>
function DP():
    dp = array of size n
    initialize dp
    for i = 1 to n:
        dp[i] = best_value_from_previous_states
    return dp[n]
        </pre>
    </details>
</section>

<footer>© 2025 Aditya</footer>

</body>
</html>
