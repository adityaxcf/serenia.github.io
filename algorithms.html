<!DOCTYPE html>
<html>
<head>
    <title>Algorithms in Serenia City</title>
    <link rel="stylesheet" href="styles.css">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<header>
    <h1>Algorithms Used in Serenia</h1>
    <p>Real-world, business-oriented applications inside a smart city model</p>
</header>

<nav>
    <a href="index.html">Home</a>
    <a href="project.html">Project</a>
    <a href="citylayout.html">City Layout</a>
    <a href="algorithms.html">Algorithms</a>
    <a href="about.html">About DAA</a>
</nav>

<!-- 1. DIJKSTRA -->
<section class="card">
    <h2>1. Dijkstra’s Algorithm – Smart Transportation & Emergency Response</h2>
    <p>Dijkstra’s algorithm powers Serenia’s routing engine. It enables:</p>
    <ul>
        <li>Fastest routes for ambulances & fire vehicles</li>
        <li>Dynamic re-routing during congestion</li>
        <li>Optimized public transport schedules</li>
    </ul>

    <details class="algo-drop">
        <summary>Show Algorithm ▼</summary>
        <div class="algo-box">
<pre>
function dijkstra(graph, source):
    dist = array of infinity
    dist[source] = 0
    visited = empty set
    pq = priority queue
    pq.push(source, 0)

    while pq not empty:
        u = pq.pop()
        if u in visited: continue
        visited.add(u)

        for each v in neighbors(u):
            if dist[u] + w(u,v) < dist[v]:
                dist[v] = dist[u] + w(u,v)
                pq.push(v, dist[v])

    return dist
</pre>
        </div>
    </details>
</section>

<!-- 2. BFS -->
<section class="card">
    <h2>2. BFS – Utility Distribution & City-Wide Service Coverage</h2>
    <p>BFS models how essential services spread across the city, ensuring:</p>
    <ul>
        <li>Full water and electricity reach</li>
        <li>Optimized garbage collection routes</li>
        <li>Emergency service accessibility</li>
    </ul>

    <details class="algo-drop">
        <summary>Show Algorithm ▼</summary>
        <div class="algo-box">
<pre>
function BFS(graph, start):
    visited = set()
    queue = [start]
    visited.add(start)

    while queue not empty:
        node = queue.pop(0)
        for each neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
</pre>
        </div>
    </details>
</section>

<!-- 3. DFS -->
<section class="card">
    <h2>3. DFS – Security & Facility Monitoring</h2>
    <p>DFS simulates deep-path inspections inside Serenia:</p>
    <ul>
        <li>CCTV route scanning</li>
        <li>Building inspection paths</li>
        <li>Maintenance route planning</li>
    </ul>

    <details class="algo-drop">
        <summary>Show Algorithm ▼</summary>
        <div class="algo-box">
<pre>
function DFS(node):
    visited.add(node)
    for each neighbor in graph[node]:
        if neighbor not in visited:
            DFS(neighbor)
</pre>
        </div>
    </details>
</section>

<!-- 4. MST -->
<section class="card">
    <h2>4. Minimum Spanning Tree – Cost-Efficient Infrastructure Planning</h2>
    <p>MST reduces city infrastructure cost by optimising networks:</p>
    <ul>
        <li>Streetlight wiring networks</li>
        <li>Power line distribution</li>
        <li>Fiber-optic layout planning</li>
    </ul>

    <details class="algo-drop">
        <summary>Show Algorithm ▼</summary>
        <div class="algo-box">
<pre>
function kruskal(graph):
    mst = set()
    sort edges by weight
    DSU = disjoint set

    for each (u, v, w) in edges:
        if find(u) != find(v):
            union(u, v)
            mst.add((u, v, w))

    return mst
</pre>
        </div>
    </details>
</section>

<!-- 5. GREEDY -->
<section class="card">
    <h2>5. Greedy Method – Fast Local Decision Making</h2>
    <p>Greedy logic is used inside Serenia for:</p>
    <ul>
        <li>Next garbage pickup selection</li>
        <li>Road patrol prioritization</li>
        <li>Peak-hour adaptive decisions</li>
    </ul>

    <details class="algo-drop">
        <summary>Show Algorithm ▼</summary>
        <div class="algo-box">
<pre>
function greedy(problem):
    solution = []

    while not done(problem):
        choice = best_local_choice(problem)
        solution.add(choice)
        update(problem, choice)

    return solution
</pre>
        </div>
    </details>
</section>

<!-- 6. DIVIDE & CONQUER -->
<section class="card">
    <h2>6. Divide & Conquer – Modular City Zoning Strategy</h2>
    <p>Serenia is divided into sub-regions for easier planning:</p>
    <ul>
        <li>Residential & commercial division</li>
        <li>Traffic load balancing</li>
        <li>Independent zone management</li>
    </ul>

    <details class="algo-drop">
        <summary>Show Algorithm ▼</summary>
        <div class="algo-box">
<pre>
function divideAndConquer(problem):
    if small(problem):
        return solve(problem)

    left, right = split(problem)
    L = divideAndConquer(left)
    R = divideAndConquer(right)
    return combine(L, R)
</pre>
        </div>
    </details>
</section>

<!-- 7. DP -->
<section class="card">
    <h2>7. Dynamic Programming – Resource Allocation Optimization</h2>
    <p>DP helps efficiently manage city-wide resources:</p>
    <ul>
        <li>Hospital bed allocation</li>
        <li>Staff scheduling</li>
        <li>Supply chain optimization</li>
    </ul>

    <details class="algo-drop">
        <summary>Show Algorithm ▼</summary>
        <div class="algo-box">
<pre>
function DP():
    dp = array

    for i in range(n):
        dp[i] = best_from_previous_states(i)

    return dp[n-1]
</pre>
        </div>
    </details>
</section>

<footer>© 2025 Aditya</footer>

</body>
</html>
