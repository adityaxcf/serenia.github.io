<!DOCTYPE html>
<html>
<head>
    <title>Algorithms in Serenia City</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>

<header>
    <h1>Algorithms Used in Serenia</h1>
    <p>How DAA concepts fit into the city design</p>
</header>

<nav>
    <a href="index.html">Home</a>
    <a href="project.html">Project</a>
    <a href="citylayout.html">City Layout</a>
    <a href="algos.html">Algorithms</a>
    <a href="about.html">About DAA</a>
</nav>

<section class="card fade-in">
    <h2>1. Dijkstra’s Algorithm – Shortest Paths</h2>
    <p>Dijkstra helps compute optimal routes inside Serenia for travel and emergency response.</p>

    <button class="algo-btn">Show Algorithm</button>
    <div class="algo-box">
        <pre>
function dijkstra(graph, source):
    dist = array of infinity
    dist[source] = 0
    visited = empty set
    pq = priority queue
    pq.push(source, 0)

    while pq is not empty:
        u = pq.pop()
        if u in visited:
            continue
        visited.add(u)

        for each neighbor v of u:
            w = weight(u, v)
            if dist[u] + w < dist[v]:
                dist[v] = dist[u] + w
                pq.push(v, dist[v])

    return dist
        </pre>
    </div>
</section>

<section class="card fade-in delay-1">
    <h2>2. BFS – Utility Reachability</h2>
    <p>BFS models how services like water and waste collection reach each zone.</p>

    <button class="algo-btn">Show Algorithm</button>
    <div class="algo-box">
        <pre>
function BFS(graph, start):
    visited = empty set
    queue = empty queue
    queue.enqueue(start)
    visited.add(start)

    while queue is not empty:
        node = queue.dequeue()
        for each neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.enqueue(neighbor)
        </pre>
    </div>
</section>

<section class="card fade-in delay-2">
    <h2>3. DFS – Security Checks</h2>
    <p>DFS simulates how deep security or inspection routes are covered.</p>

    <button class="algo-btn">Show Algorithm</button>
    <div class="algo-box">
        <pre>
function DFS(node):
    visited.add(node)
    for each neighbor in graph[node]:
        if neighbor not in visited:
            DFS(neighbor)
        </pre>
    </div>
</section>

<section class="card fade-in delay-3">
    <h2>4. Minimum Spanning Tree (Kruskal)</h2>
    <p>MST reduces wiring cost between important city nodes.</p>

    <button class="algo-btn">Show Algorithm</button>
    <div class="algo-box">
        <pre>
function kruskal(graph):
    mst = empty set
    sort edges by weight
    create disjoint set DSU

    for each edge (u, v, w):
        if find(u) != find(v):
            union(u, v)
            mst.add((u, v, w))

    return mst
        </pre>
    </div>
</section>

<section class="card fade-in delay-4">
    <h2>5. Greedy Method</h2>
    <p>Used for fast decisions like garbage pickup or patrol routing.</p>

    <button class="algo-btn">Show Algorithm</button>
    <div class="algo-box">
        <pre>
function greedy(problem):
    solution = empty set

    while not finished(problem):
        choice = best_local_choice(problem)
        solution.add(choice)
        update(problem, choice)

    return solution
        </pre>
    </div>
</section>

<section class="card fade-in delay-5">
    <h2>6. Divide & Conquer</h2>
    <p>Used to divide serenia into subzones for easier planning.</p>

    <button class="algo-btn">Show Algorithm</button>
    <div class="algo-box">
        <pre>
function divideAndConquer(problem):
    if size(problem) is small:
        return direct_solution(problem)

    left, right = split(problem)
    leftAns = divideAndConquer(left)
    rightAns = divideAndConquer(right)
    return combine(leftAns, rightAns)
        </pre>
    </div>
</section>

<section class="card fade-in delay-6">
    <h2>7. Dynamic Programming & Hashing</h2>
    <p>Used for resource allocation, record sorting, and fast lookup.</p>

    <button class="algo-btn">Show Algorithm</button>
    <div class="algo-box">
        <pre>
function DP():
    dp = array
    initialize dp

    for i from start to end:
        dp[i] = best value from previous states

    return dp[end]
        </pre>
    </div>
</section>

<footer>© 2025 Aditya</footer>

<!-- SCRIPT FOR DROPDOWN -->
<script src="script.js?v=50"></script>

</body>
</html>
