<!DOCTYPE html>
<html>
<head>
    <title>Algorithms in Serenia City</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>

<header>
    <h1>Algorithms Used in Serenia</h1>
    <p>How DAA concepts fit into the city design</p>
</header>

<nav>
    <a href="index.html">Home</a>
    <a href="project.html">Project</a>
    <a href="citylayout.html">City Layout</a>
    <a href="algos.html">Algorithms</a>
    <a href="about.html">About DAA</a>
</nav>


<!-- 1. Dijkstra -->
<section class="card fade-in">
    <h2>1. Dijkstra’s Algorithm – Shortest Paths</h2>
    <p>
        I used Dijkstra’s idea for shortest path travel between important areas of Serenia.
        It represents how emergency vehicles or daily travel routes can be optimized.
    </p>

    <button class="algo-btn">Show Algorithm</button>

    <div class="algo-box">
        <pre>
function dijkstra(graph, source):
    dist = array of infinity
    dist[source] = 0
    visited = empty set
    pq = priority queue
    pq.push(source, 0)

    while pq is not empty:
        u = pq.pop()
        if u in visited:
            continue
        visited.add(u)

        for each neighbor v of u:
            w = weight(u, v)
            if dist[u] + w < dist[v]:
                dist[v] = dist[u] + w
                pq.push(v, dist[v])

    return dist
        </pre>
    </div>
</section>


<!-- 2. BFS -->
<section class="card fade-in delay-1">
    <h2>2. BFS – Utility and Service Reachability</h2>
    <p>BFS helped me check how services spread across the city zone-by-zone.</p>

    <button class="algo-btn">Show Algorithm</button>

    <div class="algo-box">
        <pre>
function BFS(graph, start):
    visited = empty set
    queue = empty queue
    queue.enqueue(start)
    visited.add(start)

    while queue is not empty:
        node = queue.dequeue()
        for each neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.enqueue(neighbor)
        </pre>
    </div>
</section>


<!-- 3. DFS -->
<section class="card fade-in delay-2">
    <h2>3. DFS – Security & Monitoring</h2>
    <p>DFS helped model deep-path exploration like surveillance or inspection routes.</p>

    <button class="algo-btn">Show Algorithm</button>

    <div class="algo-box">
        <pre>
function DFS(node):
    visited.add(node)
    for each neighbor in graph[node]:
        if neighbor not in visited:
            DFS(neighbor)
        </pre>
    </div>
</section>


<!-- 4. Kruskal (MST) -->
<section class="card fade-in delay-3">
    <h2>4. Minimum Spanning Tree – Cost-effective Networking</h2>
    <p>MST concepts helped reduce wiring cost and overall connection distance.</p>

    <button class="algo-btn">Show Algorithm</button>

    <div class="algo-box">
        <pre>
function kruskal(graph):
    mst = empty set
    sort edges by weight
    create disjoint set DSU

    for each edge (u, v, w):
        if find(u) != find(v):
            union(u, v)
            mst.add((u, v, w))

    return mst
        </pre>
    </div>
</section>


<!-- 5. Greedy -->
<section class="card fade-in delay-4">
    <h2>5. Greedy Approach – Fast Local Decisions</h2>
    <p>Used for tasks like fast garbage pickup decisions or patrolling priorities.</p>

    <button class="algo-btn">Show Algorithm</button>

    <div class="algo-box">
        <pre>
function greedy(problem):
    solution = empty set

    while not finished(problem):
        choice = best_local_choice(problem)
        solution.add(choice)
        update(problem, choice)

    return solution
        </pre>
    </div>
</section>


<!-- 6. Divide & Conquer -->
<section class="card fade-in delay-5">
    <h2>6. Divide & Conquer – Splitting the City</h2>
    <p>Used when dividing Serenia into smaller zones for detailed planning.</p>

    <button class="algo-btn">Show Algorithm</button>

    <div class="algo-box">
        <pre>
function divideAndConquer(problem):
    if size(problem) is small:
        return direct_solution(problem)

    left, right = split(problem)
    leftAns = divideAndConquer(left)
    rightAns = divideAndConquer(right)
    return combine(leftAns, rightAns)
        </pre>
    </div>
</section>


<!-- 7. Dynamic Programming -->
<section class="card fade-in delay-6">
    <h2>7. Dynamic Programming, Sorting & Hashing</h2>
    <p>Useful for resource allocation, records organization, and fast lookups.</p>

    <button class="algo-btn">Show Algorithm</button>

    <div class="algo-box">
        <pre>
function DP():
    dp = array
    initialize dp

    for i from start to end:
        dp[i] = best value from previous states

    return dp[end]
        </pre>
    </div>
</section>


<footer>© 2025 Aditya</footer>

<script src="script.js"></script>
</body>
</html>
