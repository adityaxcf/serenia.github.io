<!DOCTYPE html>
<html>
<head>
    <title>Algorithms in Serenia City</title>
    <link rel="stylesheet" href="styles.css">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
</head>
<body>

<header>
    <h1>Algorithms Used in Serenia</h1>
    <p>How DAA concepts fit into the city design</p>
</header>

<nav>
    <a href="index.html">Home</a>
    <a href="project.html">Project</a>
    <a href="citylayout.html">City Layout</a>
    <a href="algos.html">Algorithms</a>
    <a href="about.html">About DAA</a>
</nav>

<!-- 1. DIJKSTRA -->
<section class="card fade-in">
    <h2>1. Dijkstra’s Algorithm – Shortest Paths</h2>
    <p>
        I used Dijkstra’s algorithm idea to represent how travel inside Serenia can be
        optimized. This is mainly used for shortest path travel like ambulances,
        emergency routing, and choosing the fastest route across different zones.
    </p>

    <button class="algo-btn">Show Algorithm</button>
    <div class="algo-box">
        <pre>
function dijkstra(graph, source):
    dist = array of infinity
    dist[source] = 0
    visited = empty set
    pq = priority queue
    pq.push(source, 0)

    while pq is not empty:
        u = pq.pop()
        if u in visited:
            continue
        visited.add(u)

        for each neighbor v of u:
            w = weight(u, v)
            if dist[u] + w < dist[v]:
                dist[v] = dist[u] + w
                pq.push(v, dist[v])

    return dist
        </pre>
    </div>
</section>

<!-- 2. BFS -->
<section class="card fade-in delay-1">
    <h2>2. BFS – Utility and Service Reachability</h2>
    <p>
        BFS helps me check how effectively essential services spread across Serenia.
        For example, water supply, garbage collection routes, and emergency response
        coverage. BFS explores level by level which is perfect for city-wide coverage checks.
    </p>

    <button class="algo-btn">Show Algorithm</button>
    <div class="algo-box">
        <pre>
function BFS(graph, start):
    visited = empty set
    queue = empty queue
    queue.enqueue(start)
    visited.add(start)

    while queue is not empty:
        node = queue.dequeue()
        for each neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.enqueue(neighbor)
        </pre>
    </div>
</section>

<!-- 3. DFS -->
<section class="card fade-in delay-2">
    <h2>3. DFS – Security and Monitoring</h2>
    <p>
        DFS helps represent deep-path exploration like surveillance camera scanning
        or building inspection. It explores one full path deeply before moving to the next.
    </p>

    <button class="algo-btn">Show Algorithm</button>
    <div class="algo-box">
        <pre>
function DFS(node):
    visited.add(node)
    for each neighbor in graph[node]:
        if neighbor not in visited:
            DFS(neighbor)
        </pre>
    </div>
</section>

<!-- 4. MST -->
<section class="card fade-in delay-3">
    <h2>4. Minimum Spanning Tree – Cost-Efficient Connections</h2>
    <p>
        MST helps reduce infrastructure cost in Serenia. It can represent wiring of
        streetlights, connecting major hubs with minimum cable cost, or designing 
        efficient networks.
    </p>

    <button class="algo-btn">Show Algorithm</button>
    <div class="algo-box">
        <pre>
function kruskal(graph):
    mst = empty set
    sort edges by weight
    create disjoint set DSU

    for each edge (u, v, w):
        if find(u) != find(v):
            union(u, v)
            mst.add((u, v, w))

    return mst
        </pre>
    </div>
</section>

<!-- 5. GREEDY -->
<section class="card fade-in delay-4">
    <h2>5. Greedy Method – Fast Local Decisions</h2>
    <p>
        The greedy method fits many quick decision scenarios inside Serenia such as:
        selecting the next waste collection point, deciding which road to patrol first,
        or handling peak-hour quick decisions without complex calculations.
    </p>

    <button class="algo-btn">Show Algorithm</button>
    <div class="algo-box">
        <pre>
function greedy(problem):
    solution = empty set

    while not finished(problem):
        choice = best_local_choice(problem)
        solution.add(choice)
        update(problem, choice)

    return solution
        </pre>
    </div>
</section>

<!-- 6. DIVIDE & CONQUER -->
<section class="card fade-in delay-5">
    <h2>6. Divide & Conquer – Splitting the City into Zones</h2>
    <p>
        I applied divide-and-conquer thinking while designing Serenia.  
        The city is split into regions like residential, commercial, tech park,
        sports zone, government zone, etc.  
        Each zone becomes a subproblem and then they are combined.
    </p>

    <button class="algo-btn">Show Algorithm</button>
    <div class="algo-box">
        <pre>
function divideAndConquer(problem):
    if size(problem) is small:
        return direct_solution(problem)

    left, right = split(problem)
    leftAns = divideAndConquer(left)
    rightAns = divideAndConquer(right)
    return combine(leftAns, rightAns)
        </pre>
    </div>
</section>

<!-- 7. DP -->
<section class="card fade-in delay-6">
    <h2>7. Dynamic Programming – Resource Allocation</h2>
    <p>
        DP thinking helped me understand how to allocate limited resources like
        hospital beds, emergency staff, or distributing materials efficiently.
        Sorting and hashing support quick access to city records.
    </p>

    <button class="algo-btn">Show Algorithm</button>
    <div class="algo-box">
        <pre>
function DP():
    dp = array
    initialize dp

    for i from start to end:
        dp[i] = best value from previous states

    return dp[end]
        </pre>
    </div>
</section>

<footer>© 2025 Aditya</footer>

<!-- INLINE SCRIPT (runs after DOM is ready) -->
<script>
document.addEventListener("DOMContentLoaded", () => {
  document.querySelectorAll(".algo-btn").forEach(button => {
    button.addEventListener("click", () => {
      const box = button.nextElementSibling;
      if (!box) return;
      box.classList.toggle("open");
      button.textContent = box.classList.contains("open") ? "Hide Algorithm" : "Show Algorithm";
    });
  });
});
</script>

</body>
</html>
